#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include "cache.h"

#define TOTAL_IPS 2048
#define QUEUE_SIZE 31
#define MIN_IP_APPEARANCES 15

class IPS{
  public:
	uint64_t ip;
	uint64_t last_addr;
	deque<uint64_t> deltas;
    uint32_t lru;

	IPS (){
  	  ip = 0;
	  last_addr = 0;
	  lru = 0;
	};
};

IPS history[TOTAL_IPS];

PyObject *pName, *pModule, *pFunc;
PyObject *pValue, *pArgs;


void CACHE::llc_prefetcher_initialize() 
{
    cout << "LLC delta Prefetcher" << endl;
	for (int i=0; i<TOTAL_IPS; i++)
		history[i].lru = i;

	ofstream deltafile;
	deltafile.open("delta.txt", ofstream::trunc);
	deltafile.close();
	Py_Initialize();
	pName = PyUnicode_FromString("delta");

    pModule = PyImport_Import(pName);
    Py_DECREF(pName);
    if (pModule == NULL) {
        PyErr_Print();
        fprintf(stderr, "Failed to load module delta");
        return;
    }

}

uint32_t CACHE::llc_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
	uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;
    //check if ip already in history
	int index = -1;
	for (index=0; index<TOTAL_IPS; index++){
		if (history[index].ip == ip )
			break;
	}
	//new ip
	if (index == TOTAL_IPS){
		for (index = 0; index <TOTAL_IPS; index++){
			if(history[index].lru == (TOTAL_IPS -1))
				break;
		}
		history[index].ip = ip;
		history[index].last_addr = cl_addr;

		for (int i=0; i<TOTAL_IPS; i++){
			if (history[i].lru < history[index].lru)
				history[i].lru++;
		}
		history[index].lru = 0;
		return metadata_in;
	}
	
	if (index == -1)
		assert(0);

	//we know history index
	uint64_t delta = 0;
	if (cl_addr > history[index].last_addr)
		delta = cl_addr - history[index].last_addr;
	else {
		delta = history[index].last_addr - cl_addr;
		delta *= -1;
	}
	if (delta < -128 || delta > 128)
		delta = 0;

	history[index].last_addr = cl_addr;
	if (history[index].deltas.size() == QUEUE_SIZE)
		history[index].deltas.pop_front();
	history[index].deltas.push_back(delta);

	if (history[index].deltas.size() > MIN_IP_APPEARANCES){
		pFunc = PyObject_GetAttrString(pModule, "pref_operate");
		int n = history[index].deltas.size();
		if (pFunc && PyCallable_Check(pFunc)) {
			pArgs = PyList_New(n + 1);
			PyList_SetItem(pArgs, 0, PyLong_FromLong(ip));
			for (int i=1; i<n+1; i++){
				if (PyList_SetItem(pArgs, i, PyLong_FromLong(history[index].deltas.at(i-1))) < 0){
					cout << "fail"<<endl;
				}
			}
			PyObject *arglist = Py_BuildValue("(O)",pArgs);
			Py_DECREF(pArgs);
	 		pValue = PyObject_CallObject(pFunc, arglist);
			Py_XDECREF(arglist);
        	if (pValue != NULL) {
				if (pValue != 0){
					uint64_t pythonDelta = PyLong_AsLong(pValue);
  					uint64_t pf_addr = (cl_addr + pythonDelta) << LOG2_BLOCK_SIZE;
					if ((pf_addr>>LOG2_PAGE_SIZE) == (addr >> LOG2_PAGE_SIZE)){
	  					prefetch_line(ip, addr, pf_addr, FILL_LLC, 0);
					}
				}
           		Py_DECREF(pValue);
        	}
        	else {
        		Py_DECREF(pFunc);
        		Py_DECREF(pModule);
        		PyErr_Print();
        		fprintf(stderr,"Call of pyfunc failed ip: %ld - addr: %ld\n", ip, addr);
        		return 13;
        	}
        }
        else {
        	if (PyErr_Occurred())
        		PyErr_Print();
        	fprintf(stderr, "Cannot find function\n");
        }	
      	Py_XDECREF(pFunc);
	}
	for (int i=0; i<TOTAL_IPS; i++){
		if (history[i].lru < history[index].lru)
			history[i].lru++;
	}	
    return metadata_in;
}

uint32_t CACHE::llc_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  return metadata_in;
}

void CACHE::llc_prefetcher_final_stats()
{
  cout << "LLC delta Prefetcher Final Stats" << endl;
  if( Py_FinalizeEx() < 0 ){
	return;   	
  }  
}